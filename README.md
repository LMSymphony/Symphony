# 🎼 Agentic Symphony IDE [Codename: "Symphony"]

> *"A fully orchestrated, multi-agent IDE that composes and delivers complete software projects in a single, expressive prompt — with precision, harmony, and intelligence."*

---

## 🎯 What is Agentic Symphony?
Agentic Symphony is a fully agent-driven IDE powered by a symphony of intelligent models, each acting like a musician in a grand orchestra. It enables users to:

- Generate and deploy fully functional, production-quality software projects
- From just **one prompt** — enhanced, expanded, and interpreted by multiple agents
- With version control, task backlogs, documentation, and a deployed GitHub repository

The orchestration is directed by the **Conductor** model, with models communicating, activating, and reinforcing each other musically.

---

## 🧠 Core Agentic Models & Their Roles

| Icon | Agent | Description | Inputs | Outputs |
|------|-------|-------------|--------|---------|
| 🎤 | **Enhancer-Prompt Model** | Converts user prompts into technical instructions | `prompt` | `enhanced-prompt` |
| 🎼 | **Feature Model** | Extracts system EPICs and tasks from enhanced prompts | `enhanced-prompt` | `backlog.csv` |
| 🏗️ | **Planner Model** | Designs file structure, dependencies, UI/UX, and architecture | `backlog.csv` | `plan.json` |
| 🎛️ | **Coordinator Model** | Allocates task execution, plans git strategy, and generates development flow | `plan.json` | `instructions.json` |
| 🧮 | **Code-Visualizer Model** | Converts technical tasks to pseudocode or logic blueprints | `instructions.json` | `psuedocode.txt` |
| 🧑‍💻 | **Editor Model** | Produces final code based on pseudocode and language specification | `instructions.json` | `*.py`, `*.js`, etc. |
| 🎩 | **Conductor Model** | Master orchestrator — decides when and how each model plays | **All intermediate files** | **Orchestrated execution** |

---

## ⚙️ Configuration Parameters (Shared)
Each session supports tuning the following modes:

- **Complexity**: Sets feature depth (e.g., Beginner, Intermediate, Enterprise)
- **Deep Token**: Enables semantic vector expansion to enrich prompt interpretation
- **Search Mode**: Uses local or online repository references for inspiration

These affect **all models' behavior** and are accessible globally.

---

## 🔁 Workflow Overview

### 1. 🎤 Enhancer-Prompt Model
- Takes a simple user request (e.g., "to-do app")
- Enhances it into a detailed technical prompt

### 2. 🎼 Feature Model
- Interprets the enhanced prompt
- Categorizes functionalities into EPICs
- Displays EPICs and waits for user to:
  - `🎧 Look deeper`: Break EPICs into tasks
  - `🚀 Go`: Proceed to planning phase (skip breakdown)
  - `✏️ Edit`: Manually modify EPICs or tasks

### 3. 🏗️ Planner Model
- Receives finalized tasks (from Feature model)
- Designs the project structure, flow, dependencies, visuals, and branding
- Requests user resources (e.g., logos, fonts)
- Outputs: `plan.json`

### 4. 🎛️ Coordinator Model
- Uses `plan.json` to:
  - Create execution strategy
  - Assign subtasks to models
  - Design git workflow: commits, branches, issues
- Outputs: `instructions.json`

### 5. 🧮 Code-Visualizer Model
- Translates task intent into:
  - Pseudocode
  - Logical steps
  - Mathematical formulae

### 6. 🧑‍💻 Editor Model
- Converts abstract pseudocode into real code files
- Applies framework patterns and best practices

### 7. 🎩 Conductor Model
- **Views all intermediate files** (`enhanced-prompt`, `backlog.csv`, `plan.json`, etc.)
- **Decides activation/re-activation** of any model
- **Tunes** the pipeline based on:
  - Current melody (project coherence)
  - Reinforcement (if it feels better output is possible)

The Conductor behaves:
- **Symmetrically** (sequential execution)
- Or **Reinforcement-inspired** (optimizes based on internal motivations)

---

## 📦 Intermediate Files

| File | Generated By | Description |
|------|--------------|-------------|
| `enhanced-prompt.txt` | Enhancer-Prompt | Refined prompt for downstream models |
| `backlog.csv` | Feature Model | Structured feature list in task form |
| `plan.json` | Planner | Project layout, structure, and execution blueprint |
| `instructions.json` | Coordinator | Model-specific development instructions |
| `psuedocode.txt` | Code-Visualizer | Logical flow of system |

---

## 🚀 Final Outputs
After full orchestration, the Symphony generates:

- ✅ **Production-ready codebase** (hosted on GitHub)
- 📋 **backlog.xlsx**: formatted and enriched project backlog
- 📄 **Project Documentation**: auto-generated docs with setup and usage
- 🪶 **Summary.md**: poetic explanation of how the Conductor and its agentic ensemble composed your software symphony

---

## 🧩 Supported Model Backends
Each agentic model is backed by specialized LLMs:

| Model | Backend Options (Open) | Vendor Fallback |
|-------|-------------------------|------------------|
| Enhancer | Phi-3 / DeepSeek | GPT-4-turbo |
| Feature | Mistral / StarCoder2 | Claude 3 Opus |
| Planner | DeepSeek-Coder / Gemma | GPT-4 |
| Coordinator | Yi 34B / Mixtral | GPT-4o |
| Code-Visualizer | CodeGemma / DeepSeek | StarCoder2 |
| Editor | Phind-CodeLlama / DeepSeek | Claude Sonnet |
| Conductor | Mixtral + RL logic | GPT-4o + System Prompt |

---

## 🎹 Why Music Metaphor?
- **Melodies** = development flow
- **Solfeggio frequencies** = model configurations
- **Tone skipping** = skipping detail layers ("Go")
- **Harmony** = code coherence
- **Symphony** = the orchestrated project

---

## 🛠️ Future Features
- Real-time agent visualizer (see which model is active)
- Editable intermediate files UI
- Plugin system for adding/removing instruments (models)
- Automatic performance metrics for each generated symphony

---

## 🧭 License & Credits
Built with ❤️ by the minds who believe **code is music** and IDEs should feel like art.

> *Let your prompt sing. Let your project dance.*

